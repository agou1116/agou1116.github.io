<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好累好累</title>
      <link href="/2023/06/06/%E5%A5%BD%E7%B4%AF%E5%A5%BD%E7%B4%AF/"/>
      <url>/2023/06/06/%E5%A5%BD%E7%B4%AF%E5%A5%BD%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<p>从武汉回到了广州，从一个雨天回到了另一个雨天。</p><p>线下面试（1.5h） 天扬科技（500左右人数）一次面试 两个岗位（游戏运营&#x2F;前端开发）</p><p>结果游戏运营（小姐姐，人超级好）通过，开发（小哥哥，比较活跃）欠缺（10天没摸过了好多基础的忘记了）</p><p>基本围绕js基础与计网，以及一些场景，白纸手撕深拷贝（要命，十天前还能撕，现在全忘记了）</p><p>先记录一下日期，题目过会再记录，眼下的肚子饿得出乎寻常。</p><p>想起一句诗是“我心涌悲伤的时候&#x2F;大口吃饭&#x2F;这种炫耀&#x2F;唯有风知道”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保利笔试</title>
      <link href="/2023/05/22/%E4%BF%9D%E5%88%A9%E7%AC%94%E8%AF%95/"/>
      <url>/2023/05/22/%E4%BF%9D%E5%88%A9%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gd-pub.jinshujufiles.com/hi/9159x5xDk8/20230519111739_d9f8c2" alt="【笔试】前端工程师-电商"></p><p>【笔试】前端工程师-电商</p><p>亲爱的同学，</p><p>感谢您关注和投递<strong>安利（中国）校园招聘</strong>！恭喜您通过简历筛选，进入 <strong>前端工程师-电商</strong> 职位的专业笔试环节！专业笔试具体安排如下，请您查收，并于<strong>5月25日（周四）12:00前</strong>完成答题，谢谢！</p><p>预祝专业笔试顺利！<br>如有任何问题，欢迎联系 @安利员工招聘 微信公众号，谢谢！</p><p>专业笔试</p><p><strong>一、技术知识能力</strong></p><p><strong>1. 进程与线程的关系及区别：</strong></p><p><strong>2. 斐波拉契数列求和实现：</strong></p><p>斐波那契数列（Fibonacci sequence）指的是这样一个数列：1、1、2、3、5、8、13、21、34……在数学上，斐波那契数列以如下被递推的方法定义：F(1)&#x3D;1，F(2)&#x3D;1，F(n)&#x3D;F(n - 1)+ F(n - 2)（ n ≥ 3，n ∈ N*）</p><p><strong>3. 请写一个函数，判断一个变量是否为数字类型：</strong></p><p><strong>4. 请写出以下代码输出的结果：</strong></p><p>for (var i &#x3D; 0; i &lt; 6; i++) {</p><p>  setTimeout(function () {</p><p>​    console.log(i)</p><p>  }, i * 1000)</p><p>}</p><p> for (let i &#x3D; 0; i &lt; 6; i++) {</p><p>  setTimeout(function () {</p><p>​    console.log(i)</p><p>  }, i * 1000)</p><p>}</p><p>for (var i &#x3D; 0; i &lt; 6; i++) {</p><p>  (function (i) {</p><p>​    setTimeout(function () {</p><p>​      console.log(i)</p><p>​    }, i * 1000)</p><p>  })(i);</p><p>}</p><p><strong>5. javascript中call、apply、bind方法的共同点和区别：</strong></p><p><strong>6. position定位，下列说法错误的是：</strong></p><p>fixed元素，可定位相对于浏览器窗口的指定坐标，它始终是以 body 为依据</p><p>absolute 的元素，如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者relative，那么就会依据父容器进行偏移</p><p>fixed 属性的元素在标准流中不占位置</p><p>relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间</p><p><strong>7. 请写出以下代码输出的结果：</strong></p><p>console.log(‘script start’)</p><p>async function async1() {</p><p>await async2()</p><p>console.log(‘async1 end’)</p><p>}</p><p>async function async2() {</p><p>console.log(‘async2 end’)</p><p>return Promise.resolve().then(()&#x3D;&gt;{</p><p>   console.log(‘async2 end1’)</p><p>})</p><p>}</p><p>async1()</p><p>setTimeout(function() {</p><p>console.log(‘setTimeout’)</p><p>}, 0)</p><p>new Promise(resolve &#x3D;&gt; {</p><p>console.log(‘Promise’)</p><p>resolve()</p><p>})</p><p>.then(function() {</p><p>console.log(‘promise1’)</p><p>})</p><p>.then(function() {</p><p>console.log(‘promise2’)</p><p>})</p><p>console.log(‘script end’)</p><p><strong>8. cookie、sessionStorage、localStorage的区别：</strong></p><p><strong>9. 请写出一个节流函数（throttle）和一个防抖函数（debounce）：</strong></p><p><strong>10. 什么是响应式布局？常用的实现响应式布局的方法有哪些？</strong></p><p><strong>11. 现有如下矩形元素，请使用CSS实现如下描述的动画效果：</strong></p><div class="rectangle"></div> <p>要求：</p><p>\1. 实现一个矩形从左侧移动到右侧的动画效果，矩形的宽高为200px*100px。</p><p>\2. 动画时长为3秒。</p><p>\3. 动画开始时，矩形的背景颜色为红色，结束时为绿色。</p><p>\4. 在动画结束时，矩形应该停留在右侧。</p><p>\5. 使用CSS3的动画实现方式。</p><p>\6. 不得使用JavaScript或其他编程语言。</p><p>\7. 不得使用任何框架或库。</p><p><strong>二、逻辑思维能力</strong></p><p><strong>12. 请从4个供选择的选项中选择你认为最合理的一项，来填补空缺，使之符合数列的排列规律。</strong></p><p><strong>4 2 12 28 80</strong> <strong>（ ）</strong> </p><p>124</p><p>96</p><p>216</p><p>348</p><p><strong>13. 请从4个供选择的选项中选择你认为最合理的一项，来填补空缺，使之符合数列的排列规律。</strong></p><p> 0 3 2 5 （ ）</p><p>7</p><p>4</p><p>8</p><p>12</p><p><strong>14. 2006 年某人连续打工 24 天，共赚得 190 元（日工资 10 元，星期六半天工资 5 元，星期 日休息无工资）。已知他打工是从 1 月下旬的某一天开始的，这个月的 1 日恰好是星期日， 这人打工结束的那一天是 2 月（ ）日</strong></p><p>2月6日</p><p>2月14日</p><p>2月18日</p><p>2月21日</p><p><strong>15. 由甲地到乙地有一条线路的巴士，全程行驶时间为 42 分钟，到达总站后，司机至少休息 10 分钟，巴士就调头行驶 如果这条线路甲、乙两边总站每隔 8 分钟都发一辆（不必是同一时间），则这条线路至少需多少辆巴士？</strong> </p><p>15</p><p>14</p><p>13</p><p>12</p><p><strong>16. 庆祝建国 40 周年，接受检阅的一列彩车车队共 52 辆，每辆车长 4 米，前后每辆车相隔 6 米，车队每分行驶 105 米。这列车队要通过 536 米长的检阅场地，需要多少分？</strong> </p><p>12</p><p>11</p><p>10</p><p>9</p><p><strong>17. 编号为 1 至 10 的十个果盘中，每盘都盛有水果，共盛放 100 个。其中第一盘里有 16 个， 并且编号相邻的三个果盘中水果数的和都相等，求第 8 盘中水果最多可能有几个？</strong></p><p>11</p><p>12</p><p>13</p><p>14</p><p><strong>18. 某班 44 人，从 A、 B、 C、 D、 E 五位候选人中选取班长。 A 得选票 23 张， B 得选票占第二 位， C、 D 得票相同， E 选票最少，得 4 票，那么 B 得选票（ ）张。</strong></p><p>5</p><p>6</p><p>7</p><p>8</p><p><strong>19. 某玩具店第一天卖出玩具小狗 98 个，每个获得利润 44 元 1 角；第二天卖出玩具小狗 133 个，获得的利润是成本的 40％。已知第一天卖玩具小狗所得的钱数和第二天所得的一样多， 那么每个玩具小狗的成本是 ( )元。</strong></p><p>54</p><p>50</p><p>49</p><p>45</p><p><strong>20. 请从所给的4个选项中，选择最适合的一个填在问号处，使之呈现一定的规律性。</strong></p><p><a href="https://gd-pub.jinshujufiles.com/di/9159x5xDk8/20230519113419_354aad"><img src="https://gd-pub.jinshujufiles.com/di/9159x5xDk8/20230519113419_354aad" alt="【笔试】前端工程师-电商"></a></p><p>A</p><p>B</p><p>C</p><p>D</p><p><strong>21. 请从所给的4个选项中，选择最适合的一个填在问号处，使之呈现一定的规律性。</strong></p><p><a href="https://gd-pub.jinshujufiles.com/di/9159x5xDk8/20230519113444_c43988"><img src="https://gd-pub.jinshujufiles.com/di/9159x5xDk8/20230519113444_c43988" alt="【笔试】前端工程师-电商"></a></p><p>A</p><p>B</p><p>C</p><p>D</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>singleeast面试</title>
      <link href="/2023/05/20/singleeast%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/05/20/singleeast%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>题目：</p><p>自我介绍</p><p>项目介绍（不共享屏幕）</p><p>1.简单介绍前端排列布局flex</p><p>2.flex常见属性 举例</p><p>3.flex：1与flex： 2的关系或区别（比例）</p><p>4.讲讲盒模型</p><p>5.场景：页面有很多盒子，有个盒子margin-left从正值变成了负值，会发生什么（讲了间距，讲了容器左侧溢出）</p><p>6.介绍事件冒泡（stopPropagation（））</p><p>7.阻止事件冒泡怎么做</p><p>8.什么叫事件委托（自己举了例子）</p><p>9.简单算法：判断回文数列</p><p>（说了反转比较，双指针，递归，面试官说数据结构你有想法吗，我说用栈输入外弹即可）</p><p>10.vue组件通信的方式（讲了寻常的以及eventbus，vuex，&amp;bus）</p><p>11.vue使用事件总线需要注意的方法</p><p>12.vue路由hash与history的区别</p><p>13.vue里hash会不会与锚点冲突</p><p>14.vue里history路由刷新怎么样，怎么解决这个问题</p><p>总结：面试45min，记错时间迟到了10min，问题难度基本如上，可能有遗漏，基本都回答出来，面试官很和蔼，问题有引导，并且对回答会表现肯定与夸奖，对职业规划和现状也给出了建议。</p><p>面试官反馈：singleeast一般tob给新人业务，toc给老手，技术栈是vue3，对学习能力有肯定，并且问我最近在看什么（flutter与typescript），css样式这块因为自己组织语言没有回答很快所以会让他感到需要加强（我说下去会回顾的）</p><p>后续：面试官与转推荐转换，看不懂</p><p><img src="E:\个人博客hexo\source_posts\image-20230520034542037.png" alt="image-20230520034542037"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎一面</title>
      <link href="/2023/05/16/%E7%9F%A5%E4%B9%8E%E4%B8%80%E9%9D%A2/"/>
      <url>/2023/05/16/%E7%9F%A5%E4%B9%8E%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>5&#x2F;16 15:00 知乎一面（45min）</p><p>为什么接触前端</p><p>基本只问js与vue</p><p>js数据类型分类（基本引用，还说了区分原因：存储方式（？）导致复制过程不同）</p><p>介绍原型，原型链</p><p>手写继承，深拷贝（继承没写好，深拷贝对了）</p><p>vue用过什么（vuex &#x2F;vuerouter等等）</p><p>computed，watch（自己还答了区分）</p><p>用过react吗（无）</p><p>vue的生命周期介绍一个（8个，本来还想说vue3把周期合并了没说）</p><p>里面的mount是干嘛</p><p>其他以后再看录音回忆</p><p>反映说回答没问题，就是没有实习。。。现在开发和测试人很多，二面悬</p><h2 id="5-20更新"><a href="#5-20更新" class="headerlink" title="5.20更新"></a>5.20更新</h2><p>岗位不匹配，凉</p><hr><p><img src="E:\个人博客hexo\source_posts\image-20230520035244833.png" alt="image-20230520035244833"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几道题</title>
      <link href="/2023/05/11/%E5%87%A0%E9%81%93%E9%A2%98/"/>
      <url>/2023/05/11/%E5%87%A0%E9%81%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>二叉树的最大深度<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxDepth</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> leftDepth = <span class="title function_">maxDepth</span>(root.<span class="property">left</span>)</span><br><span class="line">  <span class="keyword">const</span> rightDepth = <span class="title function_">maxDepth</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先搜索（DFS）思想，利用递归的方式遍历二叉树的每个节点，同时记录每个节点的深度，最终返回二叉树的最大深度。</p></li><li><p>另一棵树的子树<a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树 - 力扣（Leetcode）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isSubtree</span>(<span class="params">root, subRoot</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameTree</span>(root, subRoot)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isSubtree</span>(root.<span class="property">left</span>, subRoot) || <span class="title function_">isSubtree</span>(root.<span class="property">right</span>, subRoot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSameTree</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="literal">null</span> || q === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="property">val</span> !== q.<span class="property">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isSameTree</span>(p.<span class="property">left</span>, q.<span class="property">left</span>) &amp;&amp; <span class="title function_">isSameTree</span>(p.<span class="property">right</span>, q.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相同的树<a href="https://leetcode.cn/problems/same-tree/">100. 相同的树 - 力扣（Leetcode）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isSameTree</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="literal">null</span> || q === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="property">val</span> !== q.<span class="property">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isSameTree</span>(p.<span class="property">left</span>, q.<span class="property">left</span>) &amp;&amp; <span class="title function_">isSameTree</span>(p.<span class="property">right</span>, q.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>翻转二叉树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invertTree</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> temp = root.<span class="property">left</span>;</span><br><span class="line">  root.<span class="property">left</span> = <span class="title function_">invertTree</span>(root.<span class="property">right</span>);</span><br><span class="line">  root.<span class="property">right</span> = <span class="title function_">invertTree</span>(temp);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【高频】斐波那契数列<a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列 - 力扣（Leetcode）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MOD</span> = <span class="number">1000000007</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = a;</span><br><span class="line">    a = b % <span class="variable constant_">MOD</span>;</span><br><span class="line">    b = (tmp + b) % <span class="variable constant_">MOD</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>【高频】合并两个有序数组<a href="https://leetcode.cn/problems/merge-sorted-array/">. - 力扣（Leetcode）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> p = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">      nums1[p] = nums1[p1];</span><br><span class="line">      p1--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nums1[p] = nums2[p2];</span><br><span class="line">      p2--;</span><br><span class="line">    &#125;</span><br><span class="line">    p--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    nums1[p] = nums2[p2];</span><br><span class="line">    p2--;</span><br><span class="line">    p--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针</p></li><li><p>【高频】打乱数组<a href="https://leetcode.cn/problems/shuffle-an-array/">384. 打乱数组 - 力扣（Leetcode）</a></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">    [nums[i], nums[randomIndex]] = [nums[randomIndex], nums[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2023/05/09/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2023/05/09/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="常见面试智力题总结"><a href="#常见面试智力题总结" class="headerlink" title="常见面试智力题总结"></a>常见面试智力题总结</h1><p>2，5，6考过笔试题</p><h2 id="常见智力题"><a href="#常见智力题" class="headerlink" title="常见智力题"></a>常见智力题</h2><ol><li><p>时针与分针夹角度数问题？</p><p>分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当时间为 m 点 n 分时，其时针与分针夹角的度数为多少？</span><br><span class="line">  </span><br><span class="line">我们可以这样考虑，分针每走一格为 6 度，分针每走一格对应的时针会走 0.5 度。</span><br><span class="line">  </span><br><span class="line">时针每走一格为 30 度。</span><br><span class="line">  </span><br><span class="line">因此，时针走过的度数为 m * 30 + n * 0.5，分针走过的度数为 n * 6。</span><br><span class="line">  </span><br><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此时针与分针的夹角度数为 |m * 30 + n * 0.5 - n * 6|; </span><br></pre></td></tr></table></figure></li><li><p>用3升，5升杯子怎么量出4升水？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）将 5 升杯子装满水，然后倒入 3 升杯子中，之后 5 升杯子还剩 2 升水。</span><br><span class="line"></span><br><span class="line">（2）将 3 升杯子的水倒出，然后将 5 升杯子中的 2 升水倒入 3 升杯子中。</span><br><span class="line"></span><br><span class="line">（3）将 5 升杯子装满水，然后向 3 升杯子中倒水，直到 3 升杯子装满为止，此时 5 升杯子中就还剩 4 升水。</span><br></pre></td></tr></table></figure></li><li><p>四个药罐中有一个浑浊的药罐，浑浊的每片药片都比其他三个干净的药罐多一克，如何只用一次天平找出浑浊的药罐？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于浑浊的每片药片比正常药片都多出了一克，因此我认为可以通过控制药片的数量来实现判断。</span><br><span class="line"></span><br><span class="line">（1）首先将每个药罐进行编号，分别标记为 1、2、3、4 号药罐。</span><br><span class="line"></span><br><span class="line">（2）然后从 1 号药罐中取出 1 片药片，从 2 号药罐中取出 2 片药片，从 3 号药罐中取出 3 片药片，从 4 号药罐中取出 4</span><br><span class="line">    片药片。</span><br><span class="line"></span><br><span class="line">（3）将 10 片药片使用天平称重，药片的重量比正常重量多出几克，就是哪一号药罐的问题。</span><br></pre></td></tr></table></figure></li><li><p>四张卡片，卡片正面是数字，反面是字母。现在桌上四张卡片，状态为 a 1 b 2 现在我想要证明 a 的反面必然是 1<br>我只能翻两张牌，我翻哪两张？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我认为证明 a 的反面一定是 1 的充要条件为 a 的反面为 1，并且 2 的反面不能为 a，因此应该翻 a 和 2 两张牌。</span><br></pre></td></tr></table></figure></li><li><p>赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我认为一共至少需要 7 次才能选出最快的三匹马。</span><br><span class="line"></span><br><span class="line">（1）首先，我们将 25 匹马分为 5 组，每组进行比赛，选出每组最快的三匹马，其余的马由于已经不可能成为前三了，因此可以直</span><br><span class="line">    接淘汰掉，那么我们现在还剩下了 15 匹马。</span><br><span class="line"></span><br><span class="line">（2）然后我们将 5 组中的第一名来进行一轮比赛，最终的结果能够确定最快的马一定是第一名，四五名的马以及它们对应组的其余</span><br><span class="line">    马就可以淘汰掉了，因为它们已经没有进入前三的机会了。并且第二名那一组的第三名和第三组的第二第三名都可以淘汰掉了，</span><br><span class="line">    它们也没有进入前三的机会了。因此我们最终剩下了第一名那一组的二三名和第二名那一组的一二名，以及第三名一共 5 匹马，</span><br><span class="line">    它们都有竞争最快第二第三的机会。</span><br><span class="line"></span><br><span class="line">（3）最后一次对最后的 5 匹马进行比赛，选择最快的一二名作为最终结果的二三名，因此就能够通过 7 次比较，选择出最快的马。</span><br></pre></td></tr></table></figure></li><li><p>五队夫妇参加聚会，每个人不能和自己的配偶握手，只能最多和他人握手一次。A问了其他人，发现每个人的握手次数都不同，那么A的配偶握手了几次？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）由于每个人不能和自己的配偶握手，并且最多只能和他人握手一次，因此一个人最多能握 8 次手。</span><br><span class="line"></span><br><span class="line">（2）因为 A 问了除自己配偶的其他人，每个人的握手次数都不同。因此一共有九种握手的情况，由于一个人最多只能握 8 次手，因</span><br><span class="line">    此握手的情况分别为 0、1、2、3、4、5、6、7、8 这九种情况。</span><br><span class="line"></span><br><span class="line">（3）我们首先分析握了 8 次手的人，由于他和除了自己配偶的每一个人都握了一次手，因此其他人的握手次数都不为 0，因此只有</span><br><span class="line">    他的配偶握手次数为0，由此我们可以知道握手次数为 8 的人和握手次数为 0 的人是配偶。</span><br><span class="line"></span><br><span class="line">（4）我们再来分析握了 7 次手的人，他和除了握了 0 次手以外的人都握了一次手，由于握了 8 次手的人和其余人也都握了一次手</span><br><span class="line">    ，因此其他人的握手次数至少为 2 ，因此只有他的配偶的握手次数才能为 1。由此我们可以知道握手次数为 7 的人和握手次数</span><br><span class="line">    为 1 的人是配偶。</span><br><span class="line"></span><br><span class="line">（5）依次可以类推，握手次数为 6 的人和握手次数为 2 的人为配偶，握手次数为 5 的人和握手次数为 3 的人为配偶。</span><br><span class="line"></span><br><span class="line">（6）最终剩下了握手次数为 4 的人，按照规律我们可以得知他的配偶的握手次数也为4。</span><br><span class="line"></span><br><span class="line">（7）由于 A 和其他人的握手次数都不同，因此我们可以得知握手次数为 4 的人就是 A。因此他的配偶的握手次数为 4 。</span><br></pre></td></tr></table></figure></li><li><p>你只能带行走 60 公里的油，只能在起始点加油，如何穿过 80 公里的沙漠？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先走到离起点 20 公里的地方，然后放下 20 公里的油在这，然后返回起点加油。</span><br><span class="line"></span><br><span class="line">（2）当第二次到达这时，车还剩 40 公里的油，加上上一次放在这的 20 公里的油，一共就有 60 公里的油，能够走完剩下的路</span><br><span class="line">    程。</span><br></pre></td></tr></table></figure></li><li><p>烧一根不均匀的绳要用一个小时，如何用它来判断一个小时十五分钟？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一共需要三根绳子，假设分别为 1、2、3 号绳子，每个绳子一共有 A、B 两端。</span><br><span class="line"> </span><br><span class="line">（1）首先点燃 1 号绳子的 A、B 两端，然后点燃 2 号绳子的 A 端。</span><br><span class="line"></span><br><span class="line">（2）当 1 号绳子燃尽时，此时过去了半小时，然后同时点燃 2 号绳子的 B 端。</span><br><span class="line"></span><br><span class="line">（3）当 2 号绳子燃尽时，此时又过去了 15 分钟，然后同时点燃 3 号绳子的 A、B 两端。</span><br><span class="line"></span><br><span class="line">（4）当 3 号绳子燃尽时，又过去了半小时，以此一共加起来过去了一个小时十五分钟。</span><br></pre></td></tr></table></figure></li><li><p>有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1） 第一次用 7 克砝码和 2 克砝码称取 9 克盐。</span><br><span class="line"></span><br><span class="line">（2） 第二次再用第一次称取的盐和砝码称取 16 克盐。</span><br><span class="line"></span><br><span class="line">（3） 第三次再用前两次称取的盐和砝码称取 25 克盐，这样就总共称取了 50 克盐，剩下的就是 90 克。</span><br></pre></td></tr></table></figure></li><li><p>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？ </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于小鸟一直都在飞，直到两车相遇时才停下来。因此小鸟飞行的时间为两车相遇的时间，由于两车是相向而行，因此</span><br><span class="line">两车相遇的时间为总路程除以两车的速度之和，然后再用飞行的时间去乘以小鸟的速度，就能够得出小鸟飞行的距离。</span><br></pre></td></tr></table></figure></li><li><p>你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个罐子里放一个红球，第二个罐子里放剩余的球，这样概率接近75%，这是概率最大的方法</span><br></pre></td></tr></table></figure></li><li><p>假设你有8个球，其中一个略微重一些，但是找出这个球的惟一方法是将两个球放在天平上对比。最少要称多少次才能找出这个较重的球？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最少两次可以称出。</span><br><span class="line"></span><br><span class="line">首先将 8 个球分为 3 组，其中两组为 3 个球，一组为 2 个球。</span><br><span class="line"></span><br><span class="line">第一次将两组三个的球进行比较，如果两边相等，则说明重的球在最后一组里。第二次将最后一组的球进行比较即可。如</span><br><span class="line">果两边不等，则说明重的球在较重的一边，第二次只需从这一组中随机取两球出来比较即可判断。</span><br></pre></td></tr></table></figure></li><li><p>在房里有三盏灯，房外有三个开关，在房外看不见房内的情况，你只能进门一次，你用什么方法来区分那个开关控制那一盏灯？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）首先打开一盏灯 10 分钟，然后打开第二盏。</span><br><span class="line">（2）进入房间，看看那盏灯亮，摸摸那盏灯热，热的是第一个开关打开的，亮的是第二个开关打开的，而剩下的就是第三个开关打开</span><br><span class="line">    的。</span><br></pre></td></tr></table></figure></li><li><p>他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心<br>将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将每一对袜子分开，一人拿一只袜子，因为袜子不分左右脚的，因此最后每个人都能取回白袜和黑袜两对。</span><br></pre></td></tr></table></figure></li><li><p>有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（就是说<br>筐上的标签都是错的）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从混合标签里取出一个水果，取出的是什么水果，就写上相应的标签。</span><br><span class="line"></span><br><span class="line">对应水果标签的筐的标签改为另一种水果。</span><br><span class="line"></span><br><span class="line">另一种水果标签的框改为混合。</span><br></pre></td></tr></table></figure></li><li><p>一个班级60%喜欢足球，70%喜欢篮球，80%喜欢排球，问即三种球都喜欢占比有多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）首先确定最多的一种情况，就是 60% 喜欢足球的人同时也喜欢篮球和排球，此时为三种球都喜欢的人的最大比例。</span><br><span class="line"></span><br><span class="line">（2）然后确定最小的一种情况，根据题目可以知道有 40%的人不喜欢足球，30%的人不喜欢篮球，20%的人不喜欢排球，因此有最多</span><br><span class="line">    90% 的人三种球中有一种球不喜欢，因此三种球都喜欢的人的最小比例为 10%。</span><br><span class="line"></span><br><span class="line">因此三种球都喜欢的人占比为 10%-60%</span><br></pre></td></tr></table></figure></li><li><p>五只鸡五天能下五个蛋，一百天下一百个蛋需要多少只鸡？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五只鸡五天能下五个蛋，平均下来五只鸡每天能下一个蛋，因此五只鸡一百天就能够下一百个蛋。</span><br></pre></td></tr></table></figure><p>其他参考：<br><a href="https://blog.csdn.net/hilyoo/article/details/4445858">《经典面试智力题200+题和解答》</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上线</title>
      <link href="/2023/05/09/%E4%B8%8A%E7%BA%BF/"/>
      <url>/2023/05/09/%E4%B8%8A%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>ssh无法绑定&#x3D;&gt;换系统centOS，不要选windows只能远程桌面，有人建议学下vscode远程开发</p><p>改服务器密码 &#x3D;&gt;  centOS默认用户名root</p><p>宝塔公网ip无法访问&#x3D;&gt;开tcp 8888端口</p><p>宝塔默认安装6.0 &#x3D;&gt; 用官网指令安装，默认6.0，我把它升级了一下</p><p>宝塔第一次登录提示账号密码错误 &#x3D;&gt; 检查输入是正确的，后面尝试输入bt 在终端改密码，听说是系统每次登录会随机生成密码所以导致用户密码不正确（蚌）</p><p>宝塔快速安装 &#x3D;&gt; 选左边快速安装（灰常慢灰常慢）会装这四个：nginx&#x2F;mysql&#x2F;puerftpd&#x2F;php&#x2F;phpmyadmin</p><p>pm2管理器得装 &#x3D;&gt; </p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>温饭斩笔试--等我一个钟回来总结</title>
      <link href="/2023/05/08/%E6%B8%A9%E9%A5%AD%E6%96%A9%E7%AC%94%E8%AF%95/"/>
      <url>/2023/05/08/%E6%B8%A9%E9%A5%AD%E6%96%A9%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>1.5h笔试，20道选择+2编程，做完一题做下一题，选择单双混合（看代码说输出大头，考异步同步，react题大概3道，可惜我是vue技术栈只能蒙），看勾选项。</p><p>估计是海笔，5点半让7点笔试，下一场时间5.22，离谱</p><hr><p>投其他简历去了，亏贼~</p><hr><h5 id="编程："><a href="#编程：" class="headerlink" title="编程："></a>编程：</h5><p>1.给一个乱序整型数组，找出其中数字连续的最好序列，如果长度相同，返回第一个序列即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findLongestConsecutive</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numsSet = <span class="keyword">new</span> <span class="title class_">Set</span>(nums);</span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> numsSet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!numsSet.<span class="title function_">has</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> length = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> cur = num + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (numsSet.<span class="title function_">has</span>(cur)) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (length &gt; maxLength) &#123;</span><br><span class="line">        maxLength = length;</span><br><span class="line">        start = num;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [...<span class="title class_">Array</span>(maxLength).<span class="title function_">keys</span>()].<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> start + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请用JavaScript写给你一个链表的头节点head，对于列表中的每个节点node，如果其右侧存在一个严格更大值的节点，则移除node返回修改后链表的头节点head。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeNextGreaterNode</span>(<span class="params">head</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">dummy.<span class="property">next</span> = head;</span><br><span class="line"><span class="keyword">let</span> slow = dummy;</span><br><span class="line"><span class="keyword">let</span> fast = dummy.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (fast.<span class="property">next</span>.<span class="property">val</span> &gt; fast.<span class="property">val</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (slow.<span class="property">next</span> != fast.<span class="property">next</span>) &#123;</span><br><span class="line">slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">fast = slow.<span class="property">next</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">slow = fast;</span><br><span class="line">fast = fast.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择"><a href="#选择" class="headerlink" title="选择:"></a>选择:</h5><ol><li><p>onMousedown，onMouseup，onclick这仨鼠标点上去的触发顺序（就这顺序）</p></li><li><p>svg与canvas，总之svg放大不失真，canvas相反，svg肯定能存.svg文件里吧（存疑）</p></li></ol><p>​canvas api绘制一条线，这条线可独立支持事件处理器</p><p>3.xss csrf攻击相关</p><p>​设置cookie的samesite可以防范csrf攻击，设置内容安全csp利于防范xss攻击</p><p>4.涉及到数据修改用post不用get</p><p>5.quic协议解决了http2的哪些问题</p><p>6.a.使用class创建的对象仍然基于原型（√）</p><p>​b.访问一个对象不存在的属性是不会遍历整个原型链（x）</p><p>​c.所有的JavaScript对象都是object的实例（x）</p><p>​d.JavaScript使用原型继承模型实现继承</p><p>7.cors csp xss csrf哪个不属于前端的安全问题</p><p>​问得莫名奇妙，这不是四个都是？我只能选跨源cors了</p><p>8.cors定义，允许携带accept，accept-language，post，put中哪些header字段或请求方法？</p><p>​前三，另外还能用get，head方法，content-language和content-type字段（前面博客有）</p><p>9.服务器分帧，二进制分帧，头部压缩，支持长连接，哪些是http2的新特性？</p><p>​前三</p><p>10.第一Local storage中的getitem API是同步的，无需异步等待。第二同一个网址，一个HTTP，一个HTTPs，他们之间的storage相互隔离。第三local storage是本地存储与域名无关，因此可以访问到不同源的数据。第四，local storage只能存储字符串，无法直接存储map等特定结构的数据。以上四条哪些正确？</p><p>11.下面说法哪一个正确？第一Web worker技术是浏览器可以多进程执行JavaScript。第二每中每打开一个主页，就一定会生成一个渲染进程。第三，Chrome采用的是多进程架构。第四，chrome中JavaScript是单进程运的。</p><ol start="12"><li><p>Jsx语法,虚拟dom,双向数据绑定以及组件化。这四个哪些是react的特性？</p><p>除了双向</p></li><li><p>下面关于react渲染优化的说法正确的是？第一条使用react fragment不会产生额外的dom元素，可以减少不必要的加载时间。第二条Usememo可以缓存大量的计算结果，以此优化渲染速度。第三条purecomponent通过深层对比prop和state的方式避免重复渲染，优化组件性能。第四条react memo可以缓存组件，以此优化渲染速度。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>某卡准备by网友</title>
      <link href="/2023/05/07/%E6%9F%90%E5%8D%A1%E5%87%86%E5%A4%87by%E7%BD%91%E5%8F%8B/"/>
      <url>/2023/05/07/%E6%9F%90%E5%8D%A1%E5%87%86%E5%A4%87by%E7%BD%91%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<p>笔试60min，面试准备（5.8更新）：</p><p>第一轮是hr电话面，第二轮是通用技术面，第三轮是技术主管面</p><p>排序算法：<br>十种排序算法的时空复杂度：</p><ol><li><p>冒泡排序(Bubble Sort) 时间复杂度：O(n²) 空间复杂度：O(1)</p></li><li><p>选择排序(Selection Sort) 时间复杂度：O(n²) 空间复杂度：O(1)</p></li><li><p>插入排序(Insertion Sort) 时间复杂度：O(n²) 空间复杂度：O(1)</p></li><li><p>希尔排序(Shell Sort) 时间复杂度：最坏情况O(n²)，平均情况O(n log n) 空间复杂度：O(1)</p></li><li><p>归并排序(Merge Sort) 时间复杂度：O(n log n) 空间复杂度：O(n)</p></li><li><p>快速排序(Quick Sort) 时间复杂度：最坏情况O(n²)，平均情况O(n log n) 空间复杂度：O(log n) ~ O(n)</p></li><li><p>堆排序(Heap Sort) 时间复杂度：O(n log n) 空间复杂度：O(1)</p></li><li><p>计数排序(Counting Sort) 时间复杂度：O(n+k) 空间复杂度：O(n+k)</p></li><li><p>桶排序(Bucket Sort) 时间复杂度：O(n) 空间复杂度：O(n)</p></li><li><p>基数排序(Radix Sort) 时间复杂度：O(kn) 空间复杂度：O(n+k)</p></li></ol><p>还有常见的查找算法的时间空间复杂度：</p><ol><li><p>线性查找(Linear Search) 时间复杂度：O(n) 空间复杂度：O(1)</p></li><li><p>二分查找(Binary Search) 时间复杂度：O(log n) 空间复杂度：O(1)</p></li><li><p>插值查找(Interpolation Search) 时间复杂度：O(log log n) ~ O(n) 空间复杂度：O(1)</p></li><li><p>斐波那契查找(Fibonacci Search) 时间复杂度：O(log n) 空间复杂度：O(1)</p></li><li><p>树表查找(Tree Search) 时间复杂度：O(log n) 空间复杂度：O(n)</p></li><li><p>哈希查找(Hash Search) 时间复杂度：O(1) ~ O(n) 空间复杂度：O(n)</p></li><li><p>B-树(B-Tree)和B+树(B+Tree) 时间复杂度：O(log n) 空间复杂度：O(n)</p></li><li><p>红黑树(Red-Black Tree) 时间复杂度：O(log n) 空间复杂度：O(n)</p></li></ol><p>http和https区别：</p><p>安全性，端口（80，443），证书，网速，连接方式，seo影响（https优先），传输数据大小</p><p>连接方式：HTTP是无状态协议，每次请求都是相互独立的，不会保留之前的状态；而HTTPS是有状态协议，可以保留之前的上下文状态，因为SSL协议本身就是基于TCP协议的，TCP是有状态协议。</p><p>tcp udp区别：</p><ol><li>连接：TCP是面向连接的协议，建立连接后才能传输数据；而UDP是无连接的协议，数据传输不需要建立连接。</li><li>可靠性：TCP是可靠的协议，传送的数据无差错，不丢失，不重复，且按照顺序传输；而UDP是不可靠的协议，传送数据不保证完整，可能存在丢失、重复和乱序等情况。</li><li>速度：TCP的传输速度相对较慢，因为它需要建立连接和保证数据可靠性；而UDP的传输速度较快，因为它没有这些额外的开销。</li><li>适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输、电子邮件等；而UDP适用于需要快速传输的应用，如视频、音频和实时游戏等。</li><li>包大小：TCP不允许超过最大传输单元（MTU）的数据包传输；而UDP可以传输任意大小的数据包。</li></ol><p>总之，TCP和UDP各有优劣，需要根据具体的应用场景和需求选择合适的协议。在前端开发中，我们通常使用TCP协议进行HTTP请求和响应的传输，以保证数据的可靠性和完整性。对于实时性要求较高的应用，如音视频和游戏等，可以考虑使用UDP协议。</p><p>多进程和多线程：</p><p>进程间通讯：</p><p>输入URL发生了什么，另外从计算机网络结构说一下这个过程：</p><ol><li>DNS解析：浏览器首先检查本地DNS缓存是否有对应的域名解析记录，如果没有则向DNS服务器发送域名解析请求，获取服务器的IP地址。</li><li>建立TCP连接：浏览器根据服务器IP地址和端口号建立TCP连接。</li><li>发送HTTP请求：浏览器向服务器发送一个HTTP请求，请求中包含请求方法、请求资源的URL、HTTP版本号、请求头等信息。</li><li>服务器处理请求并返回HTTP响应：服务器接收到请求后处理请求并返回对应的HTTP响应，响应中包含HTTP版本号、状态码、响应头和响应实体等信息。</li><li>浏览器解析渲染页面：浏览器接收到响应后解析响应内容，如果是HTML页面则解析HTML结构，构建DOM树和CSSOM树，然后将两者合并成渲染树，最后进行页面渲染。</li></ol><p>从计算机网络结构的角度来看，这个过程可以划分为以下几个层次：</p><ol><li>应用层：浏览器发送HTTP请求并接收HTTP响应。</li><li>传输层：浏览器使用TCP协议向服务器建立连接，并在连接上发送HTTP请求和接收HTTP响应。</li><li>网络层：浏览器使用IP地址和DNS解析获得的服务器IP地址在网络层上进行数据传输。</li><li>数据链路层：数据链路层将浏览器发送的数据段封装成帧，通过物理介质传送给下一跳路由器，直到到达服务器。</li><li>物理层：物理层负责实现数据的物理传输和接收，将帧转换成电信号经由传输介质传送。</li></ol><p>socket构建TCP协议：</p><p>不是很清楚的知识点</p><p>Socket是一种网络编程的抽象概念，是网络通信的基本操作单元，可以用于实现TCP&#x2F;IP协议中的各种服务。在构建TCP协议时，可以使用Socket API实现以下步骤：</p><ol><li><p>创建Socket对象：在客户端或服务器端中使用Socket类创建一个Socket对象，指定要连接的服务器IP地址和端口号。</p></li><li><p>建立连接：客户端使用Socket连接到指定的服务器IP地址和端口号，服务器端使用Socket监听指定的端口号，等待客户端的连接请求。</p></li><li><p>传输数据：建立连接后，客户端和服务器端可以通过Socket对象发送和接收数据，实现数据传输功能。</p></li><li><p>关闭连接：数据传输完成后，客户端和服务器端使用Socket对象关闭连接，释放资源。</p></li></ol><p>TCP的可靠性的理解：</p><p>TCP协议是一种面向连接的传输协议，它具有可靠性的特点，即保证传输数据的完整性、有序性和可靠性。从前端的角度来理解TCP的可靠性，主要包括以下几个方面：</p><ol><li>数据完整性：TCP协议通过使用校验和、序列号和确认号等机制来保证数据的完整性，确保数据在传输过程中不会被修改、丢失或重复传输。</li><li>数据有序性：TCP协议使用序列号和确认号来保证数据的有序性，确保数据按照发送顺序依次传输，不会出现乱序的情况。</li><li>可靠性机制：TCP协议使用可靠性机制来保证数据的可靠性，包括超时重传、拥塞控制和流量控制等机制。超时重传机制可以检测数据是否丢失，并在超时后重新发送；拥塞控制机制可以避免网络拥塞，保证数据传输的稳定性；流量控制机制可以控制数据的发送速率，避免网络拥塞和数据丢失。</li><li>应用层协议：TCP协议为应用层协议提供了可靠的传输服务，如HTTP协议和FTP协议等都是基于TCP协议实现的，可以保证数据传输的可靠性和完整性。</li></ol><p>总之，从前端的角度来看，TCP协议是一种可靠的传输协议，能够保证数据传输的完整性、有序性和可靠性，为前端开发提供了可靠的网络通信基础。在前端开发中，我们通常使用TCP协议进行HTTP请求和响应的传输，以保证数据的可靠性和完整性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某它笔试</title>
      <link href="/2023/05/06/%E6%9F%90%E5%AE%83%E7%AC%94%E8%AF%95/"/>
      <url>/2023/05/06/%E6%9F%90%E5%AE%83%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>某他笔试（5.6）每周六19：00或22：00，考试时长2小时，视频监控，无手机绑定，可提前练习但是无答案，可推迟考试。</p><h5 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h5><p>20选择+10选择+2编程</p><h5 id="20选择（20-2）："><a href="#20选择（20-2）：" class="headerlink" title="20选择（20*2）："></a>20选择（20*2）：</h5><ul><li>允许我们删除和停用断点和监视点的是：（D）</li></ul><p>​     A.记录器视图 B.调试视图 C.变量视图 D.断点视图</p><p>​记录器视图用于查看记录的日志信息，调试视图用于查看程序执行过程中的变量值和堆栈信息，变量视图则用   于查看当前程序中的变量值。</p><ul><li><p>提供简单的单任务环境的是（A）</p><p>A.保护环境 B.实环境 C.8086环境 D.系统管理模式</p><p>保护环境是一种简单的单任务环境。在保护模式下，操作系统可以创建多个进程和线程，每个进程和线程都有自己的内存空间，可以独立运行。保护环境提供了对内存的保护机制，防止一个程序对另一个程序或操作系统的内存空间进行非法访问，从而提高了系统的安全性和稳定性。</p><p>而实模式是一种比较原始的模式，只能访问1MB以内的内存地址空间，无法进行内存保护和多任务处理，因此不属于单任务环境。8086环境是指基于Intel 8086处理器的环境，也不属于单任务环境，因为它只能支持单个进程或任务的顺序执行。系统管理模式是在保护环境下的一种特殊模式，用于执行特权操作，也不属于单任务环境。</p></li><li><p>信号量初始值为3，当前值为-2则等待进程的数量（2）</p><p>信号量的初始值为n时，当前值为m时，表示当前有n-m个资源可用，同时有|m|个进程正在等待资源。因此，若信号量的初始值为3，当前值为-2，则等待进程的数量为2。</p></li><li><p>无向图20个顶点，30条边，该图所有节点的度的和是多少（60）</p></li></ul><p>​无向图的定义，每个顶点的度数是指与该顶点相连的边的数量。</p><p>​有向图的所有节点的度的和等于所有边的数量。</p><p>​无向图所有节点的度的和 &#x3D; 2 × 所有边的数量</p><p>​        有向图所有节点的度的和 &#x3D; 所有边的数量</p><ul><li><p>折半查找条件（）</p><p>选项：顺序存储，结构存储，链式结构，元素有序，元素大小从大到小排序，元素大小从小到大排序</p><p>答案：元素有序，顺序存储</p></li><li><p>9个人在不同城市，之间两两互相打电话一共打了34场，其中2个人之间最多打1场，打过7场电话的人有（）</p><p>我选的1或2，可能用到图</p></li><li><p>二叉树可以转成树，那么通过后序遍历乙丙甲丁求先序遍历</p></li><li><p>判断广度优先遍历（BFS）</p></li><li><p>文本串简单匹配算法的时间复杂度，文本串长度n，模式串m</p><p>O（n*m）</p></li><li><p>202.16.2.193&#x2F;27与哪个是同一网段ip</p><p>27位划分一下对比就好了</p></li><li><p>多项式算法复杂度不可能是（）</p><p>选项有O（1），O（logn），O（n^3^），O（2^n^），我选的O（2^n^），不是很明白</p></li><li><p>发生死锁的条件不包括哪个</p><p>反正四个是互斥 请求与保持 不可剥夺 循环等待</p></li><li><p>协议类型，路径，权限和主机名哪一个不是URL的组成部分</p><p>权限，可以回顾这部分内容</p><h5 id="10选择（10-2）："><a href="#10选择（10-2）：" class="headerlink" title="10选择（10*2）："></a>10选择（10*2）：</h5><p>物理题，数学题和逻辑题，基本没难度</p></li></ul><h5 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h5><p>1.小美取盒子人数</p><p>小美在逛街，发现大家在排队领盲盒，只有一个领取窗口，每人领盲盒需要k时间，今天共有n个人来领盲盒，第i个人到达的时间为t<del>i</del>他的耐心为a<del>i</del>耐心意味着如果他等待了超过a<del>i</del>时间还未领到盲盒，会因失去耐心离开小美，想知道今天多少人领到了盲盒。</p><p>*输入第一行是n k（空格隔开）,第二行是t<del>i</del>，第三行是a<del>i</del>,输入的数字间用空格分开，输出要求是数字</p><p>我：通过队列的操作比较？</p><p>优化是耐心可能相同？</p><p>（require不能用，async不能用，考虑直接对readline处理）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [n,k] = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"><span class="keyword">let</span> t = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getbox</span>(<span class="params">n,k,t,a</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(arr.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> i = arr.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="keyword">let</span> wait = <span class="title class_">Math</span>.<span class="title function_">max</span>(t[i] - cur,<span class="number">0</span>)</span><br><span class="line">        cur += wait + k;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; a[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我把开头改了改也没有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> [n, k] = input[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"><span class="keyword">let</span> t = input[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"><span class="keyword">let</span> a = input[<span class="number">2</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">getbox</span>(n, k, tArr, aArr);</span><br></pre></td></tr></table></figure><p>2.小美认识的好朋友</p><p>ps ：vscode不敢打开没清文件（草），真的很难蚌赛码的编程环境，不显示错误，打字响应慢，测试有cd</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上拉加载，下拉刷新</title>
      <link href="/2023/05/05/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
      <url>/2023/05/05/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>在以前的学习中了解到了移动端有一个效果叫做“橡皮筋”，之后想到如何实现上拉实现上拉加载，下拉刷新的效果（类似知乎，抖音）。以下内容来自转载<a href="https://interview.poetries.top/weapp-interview/detail?useInfoCurrNum=1&id=0a4ec1f96310c7f31d05b95d314baa9b&queryType=&categoryId=17e3426e61e0e4da061a4773512fdd1f">前端进阶之旅 (poetries.top)</a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p><p>本质上等同于PC网页中的分页，只是交互形式不同</p><p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p><p>这些第三方库使用起来非常便捷</p><p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>上拉加载及下拉刷新都依赖于用户交互</p><p>最重要的是要理解在什么场景，什么时机下触发交互动作</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>首先可以看一张图</p><p><img src="https://706f-poetry-prod-6gj3fpxa137552a6-1258157827.tcb.qcloud.la/mardown/1646975843607-0.12024192389276145-df498a00-8ae3-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>上拉加载的本质是页面触底，或者快要触底时的动作</p><p>判断页面触底我们需要先了解一下下面几个属性</p><ul><li><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li><li><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</li><li><code>scrollHeight</code>：页面不能滚动时是不存在的，<code>body</code>长度超过<code>window</code>时才会出现，所表示<code>body</code>所有元素的长度</li></ul><p>综上我们得出一个触底公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1scrollTop + clientHeight &gt;= scrollHeight</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clientHeight  = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p><p>关于下拉刷新的原生实现，主要分成三步：</p><ul><li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li><li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li><li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li></ul><p>举个例子：</p><p><code>Html</code>结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refreshText&quot;</span>&gt;</span>&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;refreshContainer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，记录初始的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refreshContainer&#x27;</span>),</span><br><span class="line">    _refreshText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.refreshText&#x27;</span>),</span><br><span class="line">    _startPos = <span class="number">0</span>,  <span class="comment">// 初始的值</span></span><br><span class="line">    _transitionHeight = <span class="number">0</span>; <span class="comment">// 移动的距离</span></span><br><span class="line"></span><br><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    _startPos = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span>; <span class="comment">// 记录初始位置</span></span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0s&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchmove</code>移动事件，记录滑动差值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e.touches[0].pageY 当前位置</span></span><br><span class="line">    _transitionHeight = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">pageY</span> - _startPos; <span class="comment">// 记录差值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">0</span> &amp;&amp; _transitionHeight &lt; <span class="number">60</span>) &#123; </span><br><span class="line">        _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;下拉刷新&#x27;</span>; </span><br><span class="line">        _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_transitionHeight &gt; <span class="number">55</span>) &#123;</span><br><span class="line">            _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;释放更新&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>最后，就是监听<code>touchend</code>离开的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;transform 0.5s ease 1s&#x27;</span>;</span><br><span class="line">    _element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateY(0px)&#x27;</span>;</span><br><span class="line">    _refreshText.<span class="property">innerText</span> = <span class="string">&#x27;更新中...&#x27;</span>;</span><br><span class="line">    <span class="comment">// todo...</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p><ul><li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li><li>下拉到一定值时，显示松手释放后的操作提示</li><li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li></ul><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p><p>HTML结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;position-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;refresh&quot;</span>&gt;</span>下拉刷新&lt;/p &gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;position-list&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--列表内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;more&quot;</span>&gt;</span>查看更多&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BScroll</span> <span class="keyword">from</span> <span class="string">&quot;@better-scroll/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullDown</span> <span class="keyword">from</span> <span class="string">&quot;@better-scroll/pull-down&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PullUp</span> <span class="keyword">from</span> <span class="string">&#x27;@better-scroll/pull-up&#x27;</span>;</span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullDown</span>);</span><br><span class="line"><span class="title class_">BScroll</span>.<span class="title function_">use</span>(<span class="title class_">PullUp</span>);</span><br></pre></td></tr></table></figure><p>实例化<code>BetterScroll</code>，并传入相关的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageNo = <span class="number">1</span>,pageSize = <span class="number">10</span>,dataList = [],isMore = <span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">var</span> scroll= <span class="keyword">new</span> <span class="title class_">BScroll</span>(<span class="string">&quot;#position-wrapper&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">scrollY</span>:<span class="literal">true</span>,<span class="comment">//垂直方向滚动</span></span><br><span class="line">    <span class="attr">click</span>:<span class="literal">true</span>,<span class="comment">//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true</span></span><br><span class="line">    <span class="attr">pullUpLoad</span>:<span class="literal">true</span>,<span class="comment">//上拉加载更多</span></span><br><span class="line">    <span class="attr">pullDownRefresh</span>:&#123;</span><br><span class="line">        <span class="attr">threshold</span>:<span class="number">50</span>,<span class="comment">//触发pullingDown事件的位置</span></span><br><span class="line">        <span class="attr">stop</span>:<span class="number">0</span><span class="comment">//下拉回弹后停留的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//监听下拉刷新</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingDown&quot;</span>,pullingDownHandler);</span><br><span class="line"><span class="comment">//监测实时滚动</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;scroll&quot;</span>,scrollHandler);</span><br><span class="line"><span class="comment">//上拉加载更多</span></span><br><span class="line">scroll.<span class="title function_">on</span>(<span class="string">&quot;pullingUp&quot;</span>,pullingUpHandler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingDownHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    dataList=[];</span><br><span class="line">    pageNo=<span class="number">1</span>;</span><br><span class="line">    isMore=<span class="literal">true</span>;</span><br><span class="line">    $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;查看更多&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullDown</span>();<span class="comment">//每次下拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullingUpHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isMore)&#123;</span><br><span class="line">        $(<span class="string">&quot;.more&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;没有更多数据了&quot;</span>);</span><br><span class="line">        scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pageNo++;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getlist</span>();<span class="comment">//请求数据</span></span><br><span class="line">    scroll.<span class="title function_">finishPullUp</span>();<span class="comment">//每次上拉结束后，需要执行这个操作</span></span><br><span class="line">    scroll.<span class="title function_">refresh</span>();<span class="comment">//当滚动区域的dom结构有变化时，需要执行这个操作    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">y</span>&gt;<span class="number">50</span>) $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;松手开始加载&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> $(<span class="string">&#x27;.refresh&#x27;</span>).<span class="title function_">text</span>(<span class="string">&quot;下拉刷新&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getlist</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//返回的数据</span></span><br><span class="line">    <span class="keyword">let</span> result=....;</span><br><span class="line">    dataList=dataList.<span class="title function_">concat</span>(result);</span><br><span class="line">    <span class="comment">//判断是否已加载完</span></span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">length</span>&lt;pageSize) isMore=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//将dataList渲染到html内容中</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>注意点：</p><p>使用<code>better-scroll </code>实现下拉刷新、上拉加载时要注意以下几点：</p><ul><li><code>wrapper</code>里必须只有一个子元素</li><li>子元素的高度要比<code>wrapper</code>要高</li><li>使用的时候，要确定<code>DOM</code>元素是否已经生成，必须要等到<code>DOM</code>渲染完成后，再<code>new BScroll()</code></li><li>滚动区域的<code>DOM</code>元素结构有变化后，需要执行刷新 <code>refresh()</code></li><li>上拉或者下拉，结束后，需要执行<code>finishPullUp()</code>或者<code>finishPullDown()</code>，否则将不会执行下次操作</li><li><code>better-scroll</code>，默认会阻止浏览器的原生<code>click</code>事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置<code>click:true</code></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节</p><p>个人觉得是要把大致思路弄明白，实现细节目前没办法手写。。。橡皮筋效果则后面再谈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录</title>
      <link href="/2023/05/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/05/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="总结（5-3待更新）"><a href="#总结（5-3待更新）" class="headerlink" title="总结（5.3待更新）"></a>总结（5.3待更新）</h3><h5 id="1-微信小程序是单页应用吗？"><a href="#1-微信小程序是单页应用吗？" class="headerlink" title="1.微信小程序是单页应用吗？"></a>1.微信小程序是单页应用吗？</h5><p>&#x3D;&gt;是，通过路由进行页面切换</p><h5 id="2-输入输出"><a href="#2-输入输出" class="headerlink" title="2.输入输出"></a>2.输入输出</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>();</span><br><span class="line">max = <span class="title class_">Math</span>.<span class="title function_">max</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min &lt; max);</span><br><span class="line"><span class="comment">// 写出执行结果，并解释原因</span></span><br></pre></td></tr></table></figure><p>&#x3D;&gt;一般来说是true，但是结果是false：<strong>MDN 相关文档是这样解释的</strong></p><ul><li>Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。</li><li>而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false</li></ul><h5 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3.输入输出"></a>3.输入输出</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [,<span class="number">1</span>,,<span class="number">2</span>,,<span class="number">3</span>];</span><br><span class="line">array = array.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> ++i)</span><br></pre></td></tr></table></figure><p><img src="https://706f-poetry-prod-6gj3fpxa137552a6-1258157827.tcb.qcloud.la/mardown/1647652573177-0.8941865627363257-202203190916668.png" alt="img"></p><ul><li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li><li>map()会跳过空位，但会保留这个值</li><li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li></ul><p>**ES6 中都会将空位当做<code>undefined**</code>，非常重要的一点，之前处理acm模式在这个地方出过错</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染页面的不良现象&amp;重绘回流</title>
      <link href="/2023/05/04/%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%8D%E8%89%AF%E7%8E%B0%E8%B1%A1/"/>
      <url>/2023/05/04/%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%8D%E8%89%AF%E7%8E%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="浏览器的渲染原理？"><a href="#浏览器的渲染原理？" class="headerlink" title="浏览器的渲染原理？"></a>浏览器的渲染原理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</span><br><span class="line"></span><br><span class="line">（2）然后对 CSS 进行解析，生成 CSSOM 规则树。</span><br><span class="line"></span><br><span class="line">（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩</span><br><span class="line">    形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM </span><br><span class="line">    元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</span><br><span class="line"></span><br><span class="line">（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也</span><br><span class="line">    可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动</span><br><span class="line">    重排”。</span><br><span class="line"></span><br><span class="line">（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组</span><br><span class="line">    件。</span><br><span class="line"></span><br><span class="line"> 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的</span><br><span class="line"> html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其</span><br><span class="line"> 余内容。</span><br></pre></td></tr></table></figure><h4 id="渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么</span><br><span class="line">它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解</span><br><span class="line">析文档。</span><br><span class="line"></span><br><span class="line">也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的</span><br><span class="line">原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</span><br></pre></td></tr></table></figure><h4 id="async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执</span><br><span class="line">    行。</span><br><span class="line"></span><br><span class="line">（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。</span><br><span class="line">    当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</span><br><span class="line"></span><br><span class="line">（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执</span><br><span class="line">    行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</span><br></pre></td></tr></table></figure><h4 id="什么是文档的预解析？（浏览器解析过程）"><a href="#什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="什么是文档的预解析？（浏览器解析过程）"></a>什么是文档的预解析？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加</span><br><span class="line">载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析</span><br><span class="line">过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</span><br></pre></td></tr></table></figure><h4 id="CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="CSS 如何阻塞文档解析？（浏览器解析过程）"></a>CSS 如何阻塞文档解析？（浏览器解析过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可</span><br><span class="line">能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</span><br><span class="line"></span><br><span class="line">所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档</span><br><span class="line">的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，</span><br><span class="line">最后再继续文档的解析。</span><br></pre></td></tr></table></figure><h4 id="渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>渲染页面时常见哪些不良现象？（浏览器渲染过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示</span><br><span class="line">      出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 CSS 加载时间过长，或者 CSS 被放在了文档底</span><br><span class="line">      部。</span><br><span class="line"></span><br><span class="line">白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML </span><br><span class="line">     尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 JS 文件放在头部，脚本的加载会阻塞后面</span><br><span class="line">     文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</span><br></pre></td></tr></table></figure><p> <a href="https://juejin.im/entry/58f867045c497d0058e2ff3a">《前端魔法堂：解秘 FOUC》</a> <a href="https://www.jianshu.com/p/6617efa874b0">《白屏问题和 FOUC》</a></p><h4 id="如何优化关键渲染路径？（浏览器渲染过程）"><a href="#如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="如何优化关键渲染路径？（浏览器渲染过程）"></a>如何优化关键渲染路径？（浏览器渲染过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</span><br><span class="line"></span><br><span class="line">（1）关键资源的数量。</span><br><span class="line">（2）关键路径长度。</span><br><span class="line">（3）关键字节的数量。</span><br><span class="line"></span><br><span class="line">关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</span><br><span class="line"></span><br><span class="line">同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，</span><br><span class="line">并且资源越大，下载所需的往返次数就越多。</span><br><span class="line"></span><br><span class="line">最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它</span><br><span class="line">们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</span><br><span class="line"></span><br><span class="line">优化关键渲染路径的常规步骤如下：</span><br><span class="line"></span><br><span class="line">（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</span><br><span class="line">（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</span><br><span class="line">（3）优化关键字节数以缩短下载时间（往返次数）。</span><br><span class="line">（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</span><br></pre></td></tr></table></figure><p> <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn">《优化关键渲染路径》</a></p><h4 id="什么是重绘和回流？（浏览器绘制过程）"><a href="#什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="什么是重绘和回流？（浏览器绘制过程）"></a>什么是重绘和回流？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background</span><br><span class="line">      -color，我们将这样的操作称为重绘。</span><br><span class="line"></span><br><span class="line">回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样</span><br><span class="line">     的操作我们称为回流。</span><br><span class="line"></span><br><span class="line">常见引起回流属性和方法：</span><br><span class="line"></span><br><span class="line">任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</span><br><span class="line"></span><br><span class="line">（1）添加或者删除可见的 DOM 元素；</span><br><span class="line">（2）元素尺寸改变——边距、填充、边框、宽度和高度</span><br><span class="line">（3）内容变化，比如用户在 input 框中输入文字</span><br><span class="line">（4）浏览器窗口尺寸改变——resize事件发生时</span><br><span class="line">（5）计算 offsetWidth 和 offsetHeight 属性</span><br><span class="line">（6）设置 style 属性的值</span><br><span class="line">（7）当你修改网页的默认字体时。</span><br><span class="line"></span><br><span class="line">回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列</span><br><span class="line">回流。</span><br></pre></td></tr></table></figure><p>常见引起重绘属性和方法：</p><p><a href="https://camo.githubusercontent.com/50c17574fe52434a9c1199c437b8ac2a5278bf974cceea0cc37afb4b273146f1/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31342e706e67"><img src="https://camo.githubusercontent.com/50c17574fe52434a9c1199c437b8ac2a5278bf974cceea0cc37afb4b273146f1/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31342e706e67" alt="常见引起回流属性和方法"></a></p><p>常见引起回流属性和方法：</p><p><a href="https://camo.githubusercontent.com/f3843c417d526e28a0bdcfca65ecb89c611d1d73357fcbefa13c86d762e56282/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31332e706e67"><img src="https://camo.githubusercontent.com/f3843c417d526e28a0bdcfca65ecb89c611d1d73357fcbefa13c86d762e56282/68747470733a2f2f636176737a686f75796f752d313235343039333639372e636f732e61702d63686f6e6771696e672e6d7971636c6f75642e636f6d2f6e6f74652d31332e706e67" alt="常见引起重绘属性和方法"></a></p><p> <a href="https://juejin.im/post/5a9923e9518825558251c96a">《浏览器的回流与重绘》</a></p><h4 id="如何减少回流？（浏览器绘制过程）"><a href="#如何减少回流？（浏览器绘制过程）" class="headerlink" title="如何减少回流？（浏览器绘制过程）"></a>如何减少回流？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）使用 transform 替代 top</span><br><span class="line"></span><br><span class="line">（2）不要把节点的属性值放在一个循环里当成循环里的变量</span><br><span class="line"></span><br><span class="line">（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</span><br><span class="line"></span><br><span class="line">（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</span><br><span class="line"></span><br><span class="line">（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</span><br></pre></td></tr></table></figure><h4 id="为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="为什么操作 DOM 慢？（浏览器绘制过程）"></a>为什么操作 DOM 慢？（浏览器绘制过程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</span><br></pre></td></tr></table></figure><h4 id="DOMContentLoaded-事件和-Load-事件的区别？"><a href="#DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="DOMContentLoaded 事件和 Load 事件的区别？"></a>DOMContentLoaded 事件和 Load 事件的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和</span><br><span class="line">子框架的加载完成。</span><br><span class="line"></span><br><span class="line">Load 事件是当所有资源加载完成后触发的。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 场景,浏览器渲染过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单线程的JavaScript</title>
      <link href="/2023/05/03/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84JavaScript/"/>
      <url>/2023/05/03/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="主人的任务之单线程的Javascript怎么管理任务（一）"><a href="#主人的任务之单线程的Javascript怎么管理任务（一）" class="headerlink" title="主人的任务之单线程的Javascript怎么管理任务（一）"></a>主人的任务之单线程的Javascript怎么管理任务（一）</h1><p>​JavaScript是单线程还是多线程？这是我在牛客网经常刷到的问题，为了弄懂JavaScript的任务管理机制，我查阅了一些文档进行了总结：</p><h5 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的JavaScript</h5><p>​首先是JavaScript为什么是单线程？在看面经的时候，我听说别人把这种问题叫做底层问题。</p><p>​要怎么理解 JavaScript 是单线程这个概念呢？大概需要从浏览器来说起。JavaScript 最初被设计为浏览器脚本语言，主要用途包括对页面的操作、与浏览器的交互、与用户的交互、页面逻辑处理等。如果将 JavaScript 设计为多线程，那当多个线程同时对同一个 DOM 节点进行操作时，线程间的同步问题会变得很复杂。</p><p>​因此，为了<strong>避免复杂性</strong>，JavaScript <strong>被设计为单线程</strong>。</p><p>​这样一个单线程的 JavaScript，意味着任务需要一个接一个地处理。如果有一个任务是等待用户输入，那在用户进行操作前，所有其他任务都处于等待状态，页面会进入假死状态，用户体验会很糟糕。那么，为了高效进行页面的交互和渲染处理，我们围绕着任务执行是否阻塞 JavaScript 主线程，将 JavaScript 中的任务分为同步任务和异步任务。</p><h5 id="任务？什么任务？xx的任务罢了"><a href="#任务？什么任务？xx的任务罢了" class="headerlink" title="任务？什么任务？xx的任务罢了"></a>任务？什么任务？xx的任务罢了</h5><p>​对吧，这就是笔试和面试经常碰到的任务类型问题。首先作为初学者得把概念明白了。</p><p>跟考研学习到的一样：</p><ul><li>同步任务：在主线程上排队执行的任务，前一个任务完整地执行完成后，后一个任务才会被执行</li><li>异步任务：不会阻塞主线程，在其任务执行完成之后，会再根据一定的规则去执行相关的回调。</li></ul><p>围绕这两点，带着问题去翻阅文档以及询问强大的gpt配合食用，我们可以看到：</p><h5 id="同步任务与调用任务栈"><a href="#同步任务与调用任务栈" class="headerlink" title="同步任务与调用任务栈"></a>同步任务与调用任务栈</h5><p><u>JavaScript 在执行过程中每进入一个不同的运行环境时，都会创建一个相应的执行上下文。</u></p><p><strong>很好理解吧。</strong></p><p>那么，当我们执行一段 JavaScript 代码时，通常会创建多个执行上下文。</p><p>而 JavaScript 解释器会以栈的方式管理这些执行上下文、以及函数之间的调用关系，形成函数调用栈（call stack）</p><p>（调用栈可理解为一个存储函数调用的栈结构，遵循 FILO（先进后出）的原则）</p><p>注意注意，可以回顾一下栈和堆，以及它俩是干嘛用的，融合贯通嘛~</p><p><strong>我们来看一下 JavaScript 中代码执行的过程：</strong></p><ul><li>首先进入全局环境，全局执行上下文被创建并添加进栈中；</li><li>每调用一个函数，该函数执行上下文会被添加进调用栈，并开始执行；</li><li>如果正在调用栈中执行的 A 函数还调用了 B 函数，那么 B 函数也将会被添加进调用栈；</li><li>一旦 B 函数被调用，便会立即执行；</li><li>当前函数执行完毕后，JavaScript 解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li></ul><blockquote><p>由此可见，JavaScript 代码执行过程中，函数调用栈栈底永远是全局执行上下文，栈顶永远是当前执行上下文。</p></blockquote><p>在不考虑全局执行上下文时，我们可以理解为刚开始的时候调用栈是空的，每当有函数被调用，相应的执行上下文都会被添加到调用栈中。执行完函数中相关代码后，该执行上下文又会自动被调用栈移除，最后调用栈又回到了空的状态（同样不考虑全局执行上下文）。</p><p>由于栈的容量是有限制的，所以当我们没有合理调用函数的时候，可能会导致爆栈异常，此时控制台便会抛出错误（细节目前不是很明白）</p><p>这样的一个函数调用栈结构，可以理解为 JavaScript 中同步任务的执行环境，同步任务也可以理解为 JavaScript 代码片段的执行。</p><h5 id="那肯定就要问了，那你同步不是一条道嘛，这概念好弄的"><a href="#那肯定就要问了，那你同步不是一条道嘛，这概念好弄的" class="headerlink" title="那肯定就要问了，那你同步不是一条道嘛，这概念好弄的"></a>那肯定就要问了，那你同步不是一条道嘛，这概念好弄的</h5><p>同步任务的执行会阻塞主线程，也就是说，一个函数执行的时候不会被抢占，只有在它执行完毕之后，才会去执行任何其他的代码。这意味着如果我们一个任务执行的时间过长，浏览器就无法处理与用户的交互，例如点击或滚动。</p><p>因此，我们还需要用到异步任务。</p><h5 id="异步任务与回调队列"><a href="#异步任务与回调队列" class="headerlink" title="异步任务与回调队列"></a><strong>异步任务与回调队列</strong></h5><p>异步任务包括一些需要等待响应的任务，包括<u>用户交互、HTTP 请求、定时器</u>等。</p><p>我们知道，I&#x2F;O 类型的任务会有较长的等待时间，对于这类无法立刻得到结果的事件，可以使用异步任务的方式。这个过程中 JavaScript 线程就不用处于等待状态，CPU 也可以处理其他任务。</p><p>异步任务需要提供回调函数，当异步任务有了运行结果之后，该任务则会被添加到回调队列中，主线程在适当的时候会从回调队列中取出相应的回调函数并执行。</p><p>这里提到的回调队列又是什么呢？</p><p>实际上，JavaScript 在运行的时候，除了函数调用栈之外，还包含了一个待处理的回调队列。在回调队列中的都是已经有了运行结果的异步任务，每一个异步任务都会关联着一个回调函数。</p><p>回调队列则遵循 FIFO（先进先出）的原则，JavaScript 执行代码过程中，会进行以下的处理：</p><ul><li>运行时，会从最先进入队列的任务开始，处理队列中的任务；</li><li>被处理的任务会被移出队列，该任务的运行结果会作为输入参数，并调用与之关联的函数，此时会产生一个函数调用栈；</li><li>函数会一直处理到调用栈再次为空，然后 Event Loop 将会处理队列中的下一个任务。</li></ul><p><strong>这里我们提到了 Event Loop，它主要是用来管理单线程的 JavaScript 中同步任务和异步任务的执行问题。</strong>只能说江江觉得这个Event Loop不是个好东西，经常考。下面进行Event loop的总结：</p><p>学到了单线程的设计会存在阻塞问题（那是当然），为此 JavaScript 中任务被分为同步和异步任务。那么，同步任务和异步任务之间是按照什么顺序来执行的呢？下面这句话得记好：</p><p><strong>JavaScript 有一个基于事件循环的并发模型，称为事件循环（Event Loop），它的设计解决了同步任务和异步任务的管理问题。</strong></p><p>根据 JavaScript 运行环境的不同，Event Loop 也会被分成浏览器的 <code>Event Loop</code> 和 Node.js 中的 Event Loop。Node.js可以说是这个游戏比较高难的环节了。</p><p>在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：</p><ul><li><u>用户交互事件产生的事件任务，比如输入操作；</u></li><li><u>计时器产生的事件任务，比如setTimeout；</u></li><li><u>异步请求产生的事件任务，比如 HTTP 请求。</u></li></ul><p>我只能说宝子好好记住，狠狠加分~</p><p><img src="https://s.poetries.work/images/20210719145333.png" alt="img"></p><p>如图，主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程</p><ul><li>JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。</li><li>同步任务会被放在调用栈中，按照顺序等待主线程依次执行。</li><li>主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。</li><li>同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。</li><li>异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。</li><li>调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。</li></ul><p>上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。</p><p>Event Loop 的设计会带来一些问题，比如setTimeout、setInterval的时间精确性。这两个方法会设置一个计时器，当计时器计时完成，需要执行回调函数，此时才把回调函数放入回调队列中。</p><p>如果当回调函数放入队列时，假设队列中还有大量的回调函数在等待执行，此时就会造成任务执行时间不精确。</p><p>要优化这个问题，可以使用系统时钟来补偿计时器的不准确性，从而提升精确度。举个例子，如果你的计时器会在回调时触发二次计时，可以在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的计时器时间。</p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>ok,现在写到这里，过会再接着写，其实概念不是很难理解，但是这个机制对于整个的学习我认为是比较重要的原理。</p><p>其实如果我是面试官，这块可以问<strong>Setimeout，promise，async await的区别</strong>，什么事件循环啦什么宏任务啦，什么微任务啦都可以考到，搬一个八股：</p><p>setTimoout 就在script标签执行结束后才会执行，属于宏任务队列<br>Promise 本身是同步任务，只有resove() ,then()等才会加入微任务队列<br>async 函数中在await关键字之前都是同步任务<br>计算时可以将async 转换成等价的promise去运算<br>事件循环执行顺讯 ：script宏任务—&gt; 同步任务（调用栈）–&gt; 优先微任务队列–&gt;页面是否渲染？–&gt;有微任务产生优先微任务否则宏任务</p><p>祝所有人都好运，快快好起来吧~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件侦听</title>
      <link href="/2023/05/02/%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC/"/>
      <url>/2023/05/02/%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const EventUtils = &#123;</span><br><span class="line">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">  // 添加事件</span><br><span class="line">  addEvent: function(element, type, handler) &#123;</span><br><span class="line">    if (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, false);</span><br><span class="line">    &#125; else if (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element[&quot;on&quot; + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 移除事件</span><br><span class="line">  removeEvent: function(element, type, handler) &#123;</span><br><span class="line">    if (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, false);</span><br><span class="line">    &#125; else if (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element[&quot;on&quot; + type] = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 获取事件目标</span><br><span class="line">  getTarget: function(event) &#123;</span><br><span class="line">    return event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class="line">  getEvent: function(event) &#123;</span><br><span class="line">    return event || window.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class="line">  stopPropagation: function(event) &#123;</span><br><span class="line">    if (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 取消事件的默认行为</span><br><span class="line">  preventDefault: function(event) &#123;</span><br><span class="line">    if (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 写法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网</title>
      <link href="/2023/05/02/%E8%AE%A1%E7%BD%91/"/>
      <url>/2023/05/02/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>常考面试题</p><ol><li>Post 和 Get 的区别？<br>Post 和 Get 是 HTTP 请求的两种方法。</li></ol><p>（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网<br>页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。</p><p>（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</p><p>（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</p><p>（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。<br>2. TLS&#x2F;SSL 中什么一定要用三个随机数，来生成”会话密钥”？<br>客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。<br>3. SSL 连接断开后如何恢复？<br>一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</p><p>使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</p><p>另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。<br>4. RSA 算法的安全性保障？<br>对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。<br>5. DNS 为什么使用 UDP 协议作为传输层协议？<br>DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</p><p>使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU &#x3D; 576，所以为了限制报文长度不超过576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。</p><p>DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，<br>所以现在有了 DNS over HTTPS 来解决这个问题。</p><ol start="6"><li>当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？<br>  （1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li></ol><p>​   （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p><p>​   （3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p><p>​  （4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p><p>​      （5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接<br>收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的<br>确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立<br>状态，此时双方的连接就建立起来了。</p><p>​     （6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p><p>   （7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p><p>   （8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p><p>   （9）最后一步是 TCP 断开连接的四次挥手过程。</p><ol start="7"><li><p>谈谈 CDN 服务？<br>CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的<br>功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源<br>的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</p></li><li><p>什么是正向代理和反向代理？<br>我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的<br>服务都被代理服务器代替来请求。</p></li></ol><p>反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。<br>详细资料可以参考： 《正向代理与反向代理有什么区别》 《webpack 配置 proxy 反向代理的原理是什么？》</p><ol start="9"><li>负载平衡的两种实现方式？<br>一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。</li></ol><p>​另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</p><ol start="10"><li><p>http 请求方法 options 方法有什么用？<br> OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用’*’来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</p></li><li><p>http1.1 和 http1.0 之间有哪些区别？<br>http1.1 相对于 http1.0 有这样几个区别：<br>（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。<br>（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li></ol><p>​   （3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p><p>​   （4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。</p><p>​   （5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。<br>详细资料可以参考： 《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》 《HTTP 协议入门》 《网络—一篇文章详解请求头 Host 的概念》</p><ol start="12"><li><p>网站域名加 www 与不加 www 的区别？<br>详细资料可以参考： 《为什么域名前要加 www 前缀 www 是什么意思？》 《为什么越来越多的网站域名不加「www」前缀？》 《域名有 www 与没有 www 有什么区别？》</p></li><li><p>即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？<br>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p></li></ol><p>短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><p>长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p>SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不<br>需要建立过多的 http 请求，相比之下节约了资源。</p><p>上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><ol start="14"><li>怎么实现多个网站之间共享登录状态<br>在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</li></ol><p>我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将<br>页面重定向会单点登录页面。<br>详细资料可以参考： 《HTTP 是个无状态协议，怎么保持登录状态？》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/2023/05/01/%E9%93%BE%E6%8E%A5/"/>
      <url>/2023/05/01/%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/mqyqingfeng/Blog">mqyqingfeng&#x2F;Blog: 冴羽写博客的地方，预计写四个系列：JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。 (github.com)</a></p><p><a href="https://hd.nowcoder.com/link.html?target=https://github.com/ljianshu/Blog">https://hd.nowcoder.com/link.html?target=https://github.com/ljianshu/Blog</a></p><p><a href="https://hd.nowcoder.com/link.html?target=https://interview2.poetries.top/">https://hd.nowcoder.com/link.html?target=https://interview2.poetries.top/</a></p><p><a href="https://www.nowcoder.com/discuss/1048510">https://www.nowcoder.com/discuss/1048510</a></p><p><a href="https://hd.nowcoder.com/link.html?target=https://www.yuque.com/cuggz/interview/vgbphi">https://hd.nowcoder.com/link.html?target=https://www.yuque.com/cuggz/interview/vgbphi</a></p>]]></content>
      
      
      <categories>
          
          <category> 链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精度问题&amp;0.1+0.2</title>
      <link href="/2023/05/01/%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98-0-1-0-2/"/>
      <url>/2023/05/01/%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98-0-1-0-2/</url>
      
        <content type="html"><![CDATA[<p>起初在牛客网看到了一道题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil((6.8-0.9)*10); //向上取整 59</span><br><span class="line"></span><br><span class="line">Math.floor((6.8-0.9)*10); //想下取整 58</span><br><span class="line"></span><br><span class="line">Math.round((6.8-0.9)*10); //四舍五入59</span><br></pre></td></tr></table></figure><p>JavaScript 中存在精度问题，这是因为 JavaScript 中的数字采用的是 IEEE 754 标准的浮点数表示法，遵循双精度浮点数格式（即 double 类型），使用 64 位二进制表示一个数字，其中 52 位用于表示有效数字，1 位用于表示符号，11 位用于表示指数。<br>由于采用二进制表示，所以 JavaScript 中无法精确表示某些小数，例如 0.1 和 0.2，在 JavaScript 中计算它们的和可能会得到一个不精确的结果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line">const result = 0.1 + 0.2;</span><br><span class="line">console.log(result);  // Output: 0.30000000000000004</span><br></pre></td></tr></table></figure><p>上面代码中，我们计算了 0.1 和 0.2 的和，期望得到 0.3，但实际上得到的是 0.30000000000000004，这是因为 JavaScript 内部的计算采用了二进制表示，无法精确表示这两个小数。<br>为了避免精度问题，可以使用一些技巧，例如：<br>● 将数字转换为整数进行计算：例如将 0.1 和 0.2 转换为整数 1 和 2，计算它们的和得到 3，再除以 10 得到 0.3。<br>● 使用第三方库：例如 Decimal.js，它提供了高精度计算的功能，可以避免 JavaScript 中的精度问题。<br>总之，在 JavaScript 中存在精度问题，需要注意。如果需要进行精确计算，可以使用特定的工具或技巧来解决。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快排</title>
      <link href="/2023/05/01/%E5%BF%AB%E6%8E%92/"/>
      <url>/2023/05/01/%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_quickSort</span> = array =&gt; &#123;</span><br><span class="line">    <span class="comment">// 补全代码</span></span><br><span class="line">    <span class="title function_">quickSort</span>(array, <span class="number">0</span>, array.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 别忘了返回数组</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = (<span class="params">array, start, end</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意递归边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(end - start &lt; <span class="number">1</span>)    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 取第一个数作为基准</span></span><br><span class="line">    <span class="keyword">const</span> base = array[start]</span><br><span class="line">    <span class="keyword">let</span> left = start</span><br><span class="line">    <span class="keyword">let</span> right = end</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 从右往左找小于基准元素的数，并赋值给右指针 array[right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp;  array[right] &gt;= base)    right--</span><br><span class="line">        array[left] = array[right]</span><br><span class="line">        <span class="comment">// 从左往右找大于基准元素的数，并赋值给左指针 array[left]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= base)    left++</span><br><span class="line">        array[right] = array[left]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双指针重合处，将基准元素填到这个位置。基准元素已经事先保存下来了，因此不用担心上面的赋值操作会覆盖掉基准元素的值</span></span><br><span class="line">    <span class="comment">// array[left] 位置已经确定，左边的都比它小，右边的都比它大</span></span><br><span class="line">    array[left] = base</span><br><span class="line">    <span class="title function_">quickSort</span>(array, start, left - <span class="number">1</span>)</span><br><span class="line">    <span class="title function_">quickSort</span>(array, left + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具</title>
      <link href="/2023/05/01/%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/05/01/%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="常用工具知识总结"><a href="#常用工具知识总结" class="headerlink" title="常用工具知识总结"></a>常用工具知识总结</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#git">GIT</a><ul><li><a href="#1-git-%E4%B8%8E-svn-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C">1. git 与 svn 的区别在哪里？</a></li><li><a href="#2-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4">2. 经常使用的 git 命令？</a></li><li><a href="#3-git-pull-%E5%92%8C-git-fetch-%E7%9A%84%E5%8C%BA%E5%88%AB">3. git pull 和 git fetch 的区别</a></li><li><a href="#4-git-rebase-%E5%92%8C-git-merge-%E7%9A%84%E5%8C%BA%E5%88%AB">4. git rebase 和 git merge 的区别</a></li></ul></li></ul><h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h3><h4 id="1-git-与-svn-的区别在哪里？"><a href="#1-git-与-svn-的区别在哪里？" class="headerlink" title="1. git 与 svn 的区别在哪里？"></a>1. git 与 svn 的区别在哪里？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器</span><br><span class="line">出现问题，我们就没有办法使用 svn 来提交我们的代码。</span><br><span class="line"></span><br><span class="line">svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小</span><br><span class="line">并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</span><br><span class="line"></span><br><span class="line">svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</span><br></pre></td></tr></table></figure><h4 id="2-经常使用的-git-命令？"><a href="#2-经常使用的-git-命令？" class="headerlink" title="2. 经常使用的 git 命令？"></a>2. 经常使用的 git 命令？</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init                     // 新建 git 代码库</span><br><span class="line">git add                      // 添加指定文件到暂存区</span><br><span class="line">git rm                       // 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git commit -m [message]      // 提交暂存区到仓库区</span><br><span class="line">git branch                   // 列出所有分支</span><br><span class="line">git checkout -b [branch]     // 新建一个分支，并切换到该分支</span><br><span class="line">git status                   // 显示有变更的文件</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">《常用 Git 命令清单》</a></p><h4 id="3-git-pull-和-git-fetch-的区别"><a href="#3-git-pull-和-git-fetch-的区别" class="headerlink" title="3. git pull 和 git fetch 的区别"></a>3. git pull 和 git fetch 的区别</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</span><br><span class="line"></span><br><span class="line">git pull 会将远程仓库的变化下载下来，并和当前分支合并。</span><br></pre></td></tr></table></figure><p>   <a href="https://blog.csdn.net/weixin_41975655/article/details/82887273">《详解 git pull 和 git fetch 的区别》</a></p><h4 id="4-git-rebase-和-git-merge-的区别"><a href="#4-git-rebase-和-git-merge-的区别" class="headerlink" title="4. git rebase 和 git merge 的区别"></a>4. git rebase 和 git merge 的区别</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git merge 和 git rebase 都是用于分支合并，关键在 commit 记录的处理上不同。</span><br><span class="line"></span><br><span class="line">git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会</span><br><span class="line">保留之前每个分支的 commit 历史。</span><br><span class="line"></span><br><span class="line">git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后</span><br><span class="line">将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记</span><br><span class="line">录了。</span><br></pre></td></tr></table></figure><p>   <a href="https://www.jianshu.com/p/f23f72251abc">《git rebase 和 git merge 的区别》</a><br>   <a href="https://blog.csdn.net/liuxiaoheng1992/article/details/79108233">《git merge 与 git rebase 的区别》</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则表达式</title>
      <link href="/2023/05/01/codeup/"/>
      <url>/2023/05/01/codeup/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;&#x2F; （1）匹配 16 进制颜色值<br>var regex &#x3D; &#x2F;#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})&#x2F;g;</p><p>&#x2F;&#x2F; （2）匹配日期，如 yyyy-mm-dd 格式<br>var regex &#x3D; &#x2F;^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$&#x2F;;</p><p>&#x2F;&#x2F; （3）匹配 qq 号<br>var regex &#x3D; &#x2F;^[1-9][0-9]{4,10}$&#x2F;g;</p><p>&#x2F;&#x2F; （4）手机号码正则<br>var regex &#x3D; &#x2F;^1[34578]\d{9}$&#x2F;g;</p><p>&#x2F;&#x2F; （5）用户名正则<br>var regex &#x3D; &#x2F;^[a-zA-Z$][a-zA-Z0-9_$]{4,16}$&#x2F;;</p>]]></content>
      
      
      <categories>
          
          <category> 写法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer总结</title>
      <link href="/2023/05/01/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/01/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-offer-思路总结"><a href="#剑指-offer-思路总结" class="headerlink" title="剑指 offer 思路总结"></a>剑指 offer 思路总结</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>二维数组中的查找</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的</span><br><span class="line">一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：</p><p>（1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。</p><p>（2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将位置向下移动<br>，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情况下的时间复杂度为 O(n)。</p><ol start="2"><li>替换空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20</span><br><span class="line">Are%20Happy</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”</span><br><span class="line"></span><br><span class="line">str.replace(/\s/g,&quot;%20&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>从尾到头打印链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line">输入一个链表，从尾到头打印链表每个节点的值。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此来实现。栈的</span><br><span class="line">实现可以利用 Array 的 push 和 pop 方法来模拟。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>重建二叉树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输</span><br><span class="line">入前序遍历序列 &#123;1,2,4,7,3,5,6,8&#125; 和中序遍历序列 &#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到后该元素的左</span><br><span class="line">边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的递归构建。使用这种方式的</span><br><span class="line">时间复杂度为 O(n)，空间复杂度为 O(logn)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>用两个栈实现队列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈 1 和栈 2。当执行队列的 push 操作时，直接</span><br><span class="line">将元素 push 进栈 1 中。当队列执行 pop 操作时，首先判断栈 2 是否为空，如果不为空则直接 pop 元素。如果栈 2 为空，则将栈 1 中</span><br><span class="line">的所有元素 pop 然后 push 到栈 2 中，然后再执行栈 2 的 pop 操作。</span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line"></span><br><span class="line">当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>旋转数组的最小数字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的</span><br><span class="line">最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大</span><br><span class="line">小为 0，请返回 0。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相</span><br><span class="line">邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。</span><br><span class="line"></span><br><span class="line">（2）二分法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相关资料可以参考：<br><a href="https://www.cnblogs.com/edisonchou/p/4746561.html">《旋转数组的最小数字》</a></p><ol start="7"><li>斐波那契数列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n&lt;=39</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">斐波那契数列的规律是，第一项为 0，第二项为 1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，不断通过叠</span><br><span class="line">加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li>跳台阶</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">跳台阶的问题是一个动态规划的问题，由于一次只能够跳 1 级或者 2 级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 跳上，一</span><br><span class="line">种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。</span><br><span class="line"></span><br><span class="line">和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>变态跳台阶</li></ol><p>题目：</p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>思路：</p><p>变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有项的值的和。</p><p>f(1) &#x3D; 1<br>f(2) &#x3D; f(2-1) + f(2-2) &#x2F;&#x2F;f(2-2) 表示 2 阶一次跳 2 阶的次数。<br>f(3) &#x3D; f(3-1) + f(3-2) + f(3-3)<br>…<br>f(n) &#x3D; f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n)</p><p>再次总结可得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        | 1 ,(n=0 )</span><br><span class="line">f(n) =  | 1 ,(n=1 )</span><br><span class="line">        | 2\*f(n-1),(n&gt;=2)</span><br></pre></td></tr></table></figure><ol start="10"><li>矩形覆盖</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line"></span><br><span class="line">我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共</span><br><span class="line">有多少种方法？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">依旧是斐波那契数列的应用</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="11"><li>二进制中 1 的个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后</span><br><span class="line">面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判</span><br><span class="line">断这个数可以经历多少次这样的过程。</span><br><span class="line"></span><br><span class="line">如：1100&amp;1011=1000</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="12"><li>数值的整数次方</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="13"><li>调整数组顺序使奇数位于偶数前面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半</span><br><span class="line">部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数就将它加入到</span><br><span class="line">奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的时间复杂度为 O(n)，空间</span><br><span class="line">复杂度为 O(n)。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="14"><li>链表中倒数第 k 个节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，输出该链表中倒数第 k 个结点。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个指针同时向后</span><br><span class="line">移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="15"><li>反转链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个链表，反转链表后，输出链表的所有元素。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍历，首先将当</span><br><span class="line">前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节点，current 设置为 ne</span><br><span class="line">xt 节点，实现下一次循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="16"><li>合并两个排序的链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的方式，依次将两个链表的元素递归进行对比。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="17"><li>树的子结构</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入两棵二叉树 A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">通过递归的思想来解决</span><br><span class="line"></span><br><span class="line">第一步首先从树 A 的根节点开始遍历，在左右子树中找到和树 B 根结点的值一样的结点 R 。</span><br><span class="line">第二步两棵树同时从 R 节点和根节点以相同的遍历方式进行遍历，依次比较对应的值是否相同，当树 B 遍历结束时，结束比较。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="18"><li>二叉树的镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">操作给定的二叉树，将其变换为源二叉树的镜像。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">从根节点开始遍历，首先通过临时变量保存左子树的引用，然后将根节点的左右子树的引用交换。然后再递归左右节点的子树交换。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="19"><li>顺时针打印矩阵</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，</span><br><span class="line">例如，如果输入如下矩阵： 1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br><span class="line">13 14 15 16</span><br><span class="line">则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">（1）根据左上角和右下角可以定位出一次要旋转打印的数据。一次旋转打印结束后，往对角分别前进和后退一个单位，可以确定下一</span><br><span class="line">次需要打印的数据范围。</span><br><span class="line"></span><br><span class="line">（2）使用模拟魔方逆时针解法，每打印一行，则将矩阵逆时针旋转 90 度，打印下一行，依次重复。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="20"><li>定义一个栈，实现 min 函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">题目：</span><br><span class="line"></span><br><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line"></span><br><span class="line">使用一个辅助栈，每次将数据压入数据栈时，就把当前栈里面最小的值压入辅助栈当中。这样辅助栈的栈顶数据一直是数据栈中最小</span><br><span class="line">的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="21"><li>栈的压入弹出</li></ol><pre><code>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）思路：我们可以使用一个辅助栈的方式来实现，首先遍历压栈顺序，依次将元素压入辅助栈中，每次压入元素后我们首先判断该元素是否与出栈顺序中的此刻位置的元素相等，如果不相等，则将元素继续压栈，如果相等，则将辅助栈中的栈顶元素出栈，出栈后，将出栈顺序中的位置后移一位继续比较。当压栈顺序遍历完成后，如果辅助栈不为空，则说明该出栈顺序不正确。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎笔试</title>
      <link href="/2023/05/01/%E7%9F%A5%E4%B9%8E%E7%AC%94%E8%AF%95/"/>
      <url>/2023/05/01/%E7%9F%A5%E4%B9%8E%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="10单选-5多选-2编程（4-27校招笔试）"><a href="#10单选-5多选-2编程（4-27校招笔试）" class="headerlink" title="10单选+5多选+2编程（4.27校招笔试）"></a>10单选+5多选+2编程（4.27校招笔试）</h1><p>题库与网上相同</p><h2 id="编程题（2）"><a href="#编程题（2）" class="headerlink" title="编程题（2）"></a>编程题（2）</h2><ol><li><p>求字符串最大和 <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣（Leetcode）</a></p><p>力扣第53题：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>AC</p></li><li><p>给定url输出指定参数key的参数值，存在相同key输出最后一个</p><p>AC(70%)</p></li></ol><h2 id="单选题（10）"><a href="#单选题（10）" class="headerlink" title="单选题（10）"></a>单选题（10）</h2><p>回忆版：</p><ol><li><p>以下哪个事件支持冒泡：</p><p>A: focus; B: Scroll; C: mouseenter; </p></li><li><p>给出中叉树的中序遍历与后序遍历，求先序遍历</p></li><li><p>关于盒子模型的描述正确的是：</p><p>标准盒模型与IE盒模型的盒子总宽度怎么算；</p></li><li><p>描述错误的是;</p><p>A: domContentLoaded事件早于onload事件</p><p>B: HTTP状态码302表示临时重定向，请求的网页已经临时移动到新位置；</p><p>C: 事件捕获是由内向外的，最内部元素最先触发；</p><p>D: event，preventDefault（）阻止元素发生默认的行为；</p></li><li><p>关于XSS与CSRF跨站攻击描述正确的是：</p><p>A: XSS 会以你的名义，发送恶意请求获取相关数据；</p><p>B: 过滤用户输入的特殊字符可以有效防御 CSRF；</p><p>C: XSS是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法；</p><p>D：进行referer与token校验可以有效防御CSRF</p></li><li><p>CSS不是继承特性的是：</p><p>A: font-size； B: line-height; C: justify-content; D: text-indent;</p></li><li><p>原型链</p></li><li><p>[]的ValueOf和同toString结果是什么：</p></li><li><p>看代码说输出，涉及了process.nextTick(),箭头函数，setTimeout()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;, 10);</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line">while (Math.random() &lt; 0.99999);</span><br><span class="line">console.log(6);</span><br></pre></td></tr></table></figure></li><li><p>忘了</p></li></ol><h2 id="多选题（5）"><a href="#多选题（5）" class="headerlink" title="多选题（5）"></a>多选题（5）</h2><ol><li><p>表达式值为true：</p></li><li><p>网络七层协议：</p></li><li><p>关于闭包描述正确的是;</p></li><li><p>关于call()和apply()正确的是：</p></li><li><p>关于cookie，localStorage和sessionStorage哪个说法是错误的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.22面试</title>
      <link href="/2023/05/01/4-22%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/05/01/4-22%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>50min 视频会议 简创（餐饮）</p><p>http与https的区别；<br>内存与磁盘的区别；<br>三大件有做过什么小游戏之类吗；<br>介绍一下浏览器缓存；<br>如果我想把chatgpt的对话内容保存怎么做；<br>localStorage有用过吗，和sessionStorage的区别；<br>css优先级，遇到错误怎么处理请举例；<br>如果让你从0到1建一个项目，你考虑的点是什么，有哪些流程需要注意的。<br>Sass，LESS预处理器，自己怎么用的；<br>说一下使用vuex的好处；<br>有做过后端吗；<br>怎么实现项目功能的？是静态的吗；<br>api接口为什么封装；<br>axios传递参数的方式以及区别；<br>get与post请求的区别；<br>element-ui怎么用的，需要修改怎么改；<br>Babel的用处；<br>菜单的实现；<br>为什么要判断登陆设备，项目有写这块吗？怎么实现；<br>less预处理器；<br>做过优化吗；<br>介绍一下request怎么写的；<br>路由怎么写的；<br>项目的二维码登录调用接口需要自己生成吗？</p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2023/05/01/CSS/"/>
      <url>/2023/05/01/CSS/</url>
      
        <content type="html"><![CDATA[<p>CSS3的新特性<br>transition：过渡<br>transform: 旋转、缩放、移动或倾斜<br>animation: 动画<br>gradient: 渐变<br>box-shadow: 阴影<br>border-radius: 圆角<br>word-break: normal|break-all|keep-all; 文字换行(默认规则|单词也可以换行|只在半角空格或连字符换行)<br>text-overflow: 文字超出部分处理<br>text-shadow: 水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。<br>box-sizing: content-box|border-box 盒模型<br>媒体查询 @media screen and (max-width: 960px) {}还有打印print</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
